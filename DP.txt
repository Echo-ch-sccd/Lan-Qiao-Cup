#硬币问题――动态规划
#DP――递推关系不好找啊?!
def solve(s):
    Min=[int(1e12)]*(s+1)
    Min[0]=0
    for i in range(cnt):
        for j in range(type[i],s+1,type[i]):
            Min[j]=min(Min[j],Min[j-type[i]]+1)
    print(Min[s])

cnt=5
type=[1,5,10,25,50]
s=int(input())
solve(s)



#0/1背包问题：
def solve(N,C):
    for i in range(1,N+1):
        for j in range(0,C+1):
            if c[i]>j: dp[i][j]=dp[i-1][j]
            else: dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i]]+w[i])
    return dp[N][C]
    
n=3011
dp=[[0]*n for i in range(n)]
N,C=init(input().split())
c=[0]*n
w=[0]*n
for i in range(1,N+1):
    c[i],w[i]=map(int,input().split())
print(solve(N,C))



#装箱问题――只考虑体积，较上题简单：
#写两个代码：第一个是照上一题写的
def solve(V,n):
    for i in range(1,n+1):
        for j in range(0,V+1):
            if v[i]>j: dp[i][j]=dp[i-1][j]
            else: dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+v[i])
    return V-dp[n][V]

V=int(input())
n=int(input())
dp=[[0]*(V+1) for i in range(n+1)]
v=[0]*31
for i in range(1,n+1):
    v[i]=int(input())
print(solve(V,n))


#这是第二种：简化方式
dp=[0]*20010
V=int(input())
n=int(input())
c=[0]*40
for i in range(1,n+1): c[i]=int(input())
for i in range(1,n+1):
    for j in range(V,c[i]-1,-1):
        dp[j]=max(dp[j],dp[j-c[i]]+c[i])
a=V-dp[V]
print(a)
