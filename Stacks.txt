#静态数组表示二叉树

#先根遍历
def postorder(p):
    print(tree(p),end=' ')
    if tree[2*p]!=' ':
        postorder(2*p)
    if tree[2*p+1]!=' ':
        postorder(2*p+1)

#中根遍历
def postorder(p):
    if tree(2*p)!=' ':
        postorder(2*p)
        
    print(tree(p),end)
    
    if tree(2*p+1)!=' ':
        postorder(2*p+1)

#后根遍历
def postorder(p):
    if tree[2*p]!=' ':
        postorder(2*p)
    if tree[2*p+1]!=' ':
        postorder(2*p+1)
    print(tree[p],end=' ')



#二叉树例题：
import math

n=int(input())
c=int(math.log(n,2))+1		#c必须为int,而不能为float

a=[0]+list(map(int,input().split()))
s=[0]*(c+1)

for i in range(1,c+1):
    s[i]=sum(a[2**(i-1):2**i])#第i层的数字从2^(i-1)到2^i-1
    print(s[i])
print(s.index(max(s)))


def build_FBI(p,left,right):
    if left==right:
        if s[right]=='1': tree[p]='I'
        else:         tree[p]='B'
        return
    mid=[left+right]//2
    build_FBI(2*p,left,mid)
    build_FBI(2*p+1,mid+1,right)
    if tree[2*p]=='B' and tree[2*p+1]=='B': tree[p]='B'
    elif tree[2*p]=='I' and tree[2*p+1]=='I': tree[p]='I'
    else: tree[p]='F'

def postorder(p):
    if tree[2*p] !='': postorder(2*p)
    if tree[2*p+1]!='': postorder(2*p+1)
    print(tree[p],end='')

n=int(input())
s=input() 
tree=['']*4400
build_FBI(1,0,len(s)-1)
postorder(1)
