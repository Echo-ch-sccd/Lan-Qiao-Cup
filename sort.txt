

a='WHERETHEREISAWILLTHEREISAWAY'
b=sorted(a)
print(b)

打印出来：['A', 'A', 'A', 'E', 'E', 'E', 'E', 'E', 'E', 'H', 'H', 'H', 'I', 'I', 'I', 'L', 'L', 'R', 'R', 'R', 'S', 'S', 'T', 'T', 'W', 'W', 'W', 'Y']


a='WHERETHEREISAWILLTHEREISAWAY'
b=sorted(a)
print(''.join(b))

打印出来为: AAAEEEEEEHHHIIILLRRRSSTTWWWY

a=list('WHERETHEREISAWILLTHEREISAWAY')
a.sort()
print(''.join(a))

打印出来为：AAAEEEEEEHHHIIILLRRRSSTTWWWY



n=int(input())
num=[]
for i in range(n):
    num.append(int(input()))    #读n行的数据!!!
key=list(set(num))  #set去重
key.sort
for i in key:
　　print(i,num.count(i))

#

#为什么字典能去重？？？
n=int(input())
nums={}
for i in range(n):
    x=int(input())
    if x in nums.keys():
        nums[x]+=1
    else:
        nums[x]=1
key=list(nums.keys())
key.sort()
for i in key:
　　print(i,nums[i])


#错误票据
n=int(input())
a=[]
for i in range(n):
    num=input().split()			#把上面读n行数据，重复一下，加个循环！！！
    for j in range(len(num)):
        a.append(int(num[j]))
a.sort()
for i in range(a[0],a[0]+len(a)):
    if i not in a:
        ans1=i
    if a.count(i)==2:
        ans2=i
print(ans1,ans2)



#结构体排序！！！
#奖学金问题！
n=int(input())
scores=[]
for i in range(n):
    score=list(map(int,input().split()))
    scores.append([i+1,sum(score)]+score)
index=reversed((1,2,0))
for i in index:
    scores.sort(key=lambda x:x[i],reverse=True)
for i in range(5):
　　print(scores[i][0],scores[i][1])


#双向排序
n,m=map(int,input().split())
a=[i for i in range(1,n+1)]
for i in range(m):
    p,q=map(int,input().split())
    if p==0:
        c=a[:p]
        c.sort()
        a[:p]=c
    else:
        b=a[p-1:n]
        b.sort(reverse=True)
        a[p-1:n]=b
for i in a:
　　print(i,end='')


n,m=map(int,input().split())
a=[i for i in range(1,n+1)]
for i in range(m):
    p,q=map(int,input().split())
    if p==0:
        a=sorted(a[:q],reverse=True)+a[q:]
    else:
        a=a[:q-1]+sorted(a[q-1:])
for i in a:
　　print(i,end='')



#第几个幸运数字
n=59084709587505
a=[1]
k=0
while True:
    for i in (3,5,7):
        tmp=i*a[k]
        if tmp not in a:
             a.append(tmp)
             a.sort（）
        if tmp>2**64:
            print(a.index(n))
            exit(0)###不用break
　　k+=1


cnt=0
for i in range(50):
    for j in range(50):
        for k in range(50):
            a=3**i
            b=5**j
            c=7**k
            if a*b*c<=59084709587505:
                cnt+=1
print(cnt-1)    #不包括1



###排列组合：
from itertools import *
s=['a','b','c']
for element in permutations(s):
    print(element)  #展示一下element是什么内容？！
    a=''.join(element)  ###适用于各种形式的“字符”，不能用于数字！
    print(a,end='')


from itertools import *
s=[1,2,3]
for element in permutations(s):
    #print(element)  #展示一下element是什么内容？！
    for j in element:
        print(j,end='')
    print(' ',end=' ')  #每个组合之间两个空格
　　#print(end=' ')      #每个组合之间一个空格


from itertools import *
s=[1,3,2]
#s.sort()
for i in permutations(s):
　　print(i,end='')



#combinations（）
#1.不同位置的13和13是不一样的，会重复出现；
#2.但是13和31是一样的，不许重复；
#3.不同位置的11和11是一样的，不需重复。
###其实也是按位置分组，不同组合的位置一样，就去掉。故可以解释上述三种情况！！！
from itertools import *
s=['1','1','3','2']
for element in combinations(s,2):
    a=''.join(element)
    print(a,end=' ')



#用set去重，再sort排序，然后组合
from itertools import *
s={'1','1','3','2'}
t=list(set(s))
t.sort()
#t=sorted(set(s))
for element in combinations(t,2):
    a=''.join(element)
    print(a,end=' ')



#DFS的手写方法
#暴力循环
s=[1,2,3,4]
for i in range(4):
    for j in range(4):
        if j !=i:
            for k in range(4):
                if k !=i and k !=j:
                    #print(f'{s[i]}{s[j]}{s[k]}',end=' ')
                    print('%d%d%d'%(s[i],s[j],s[k]),end=' ')


s=[1,2,3,4]
for i in range(4):
    for j in range(i+1,4):
        for k in range(j+1,4):
            print('%d%d%d'%(s[i],s[j],s[k]),end=' ')


#手写组合代码：二进制法
#子集刚好对应二进制数！！！
a=[1,2,3,4,5,6]
n=3
for i in range(1<<n):
    print('{',end='')
    for j in range(n):
        if i & (1<<j):  #对应的i的二进制与1的左移作与运算；若不为0，则j位置为1，存在子集元素
            print(a[j],end='')
　　print('}',end=' ')



#输出n个数中任意个m数的组合
a=[1,2,3,4,5,6,7]
def print_set(n,m):
    for i in range(1<<n):
        num,k=0,i
        while (k>0):
            k=k&(k-1)
            num+=1
        if num==m:
            for j in range(n):
                if i&(1<<j):
                    print(a[j],end='')
            print(end=';')

n,m=4,3
print_set(n,m)


#排列序数：
from itertools import *
a=input()
b=list(a)
b.sort()
cnt=0
for element in permutations(b):
    c=''.join(element)
    if c==a:
        print(cnt)
        break
　　cnt+=1



from itertools import *
olds=input()
news=sorted(olds)
cnt=0
for element in permutations(news):
    c=''.join(element)
    if olds==c:
        print(cnt)
        break
　　cnt+=1



#拼数：
from itertools import *
n=int(input())
nums=list(map(str,input().split()))
ans=''
for element in permutations(nums):
    a=''.join(element)
    if ans <a:
        ans=a
print(ans)


n=int(input())
nums=input().split()
for i in range(n-1):
    for j in range(i+1,n):
        if nums[i]<nums[j]:
            nums[i],nums[j]=nums[j],nums[i]
print(''.join(nums))



#火星人：
from itertools import *
from copy import *
n=int(input())
m=int(input())
num=list(map(str,input().split()))
num.sort()
back=deepcopy(num)
flag=0
k=0
for element in permutations(num):
    if back==list(element):
        flag=1           #以后flag都等于1
    if flag==1:
        if k==m:
            a=''.join(element)
            print(a)
            break
        k+=1



#手写下一个排列
#从最小位开始与上一位对比，上一位小于下一位，则两者交换
n=int(input())
m=int(input())
nums=list(map(str,input().split()))
def find_next(nums):
    for i in range(n-1,0,-1):
        if nums[i]>nums[i-1]:
            for j in range(n-1,i-1,-1):
                if nums[j]>nums[i-1]:
                    nums[j],nums[i-1]=nums[i-1],nums[j]
                    return nums[:i]+nums[:-i:-1]


for i in range(m):
    num=find_next(nums)
print(' '.join([str(i) for i in nums]))
